# JUCE Framework Knowledge Base

**Purpose:** Comprehensive guide to JUCE C++ audio framework for building Performia's low-latency audio engine

**Last Updated:** October 4, 2025

---

## üéØ What is JUCE?

JUCE (Jules' Utility Class Extensions) is an open-source cross-platform C++ application framework for desktop and mobile applications, particularly focused on audio applications including:
- VST, VST3, AU, AUv3, LV2, and AAX audio plugins
- Standalone audio applications
- Real-time audio processing
- MIDI handling
- DSP (Digital Signal Processing)

**Official Site:** https://juce.com/
**GitHub:** https://github.com/juce-framework/JUCE

---

## üèóÔ∏è Architecture Overview

### Core Components

1. **Audio Module**
   - `AudioProcessor` - Base class for audio plugins
   - `AudioDeviceManager` - Manages audio I/O devices
   - `AudioFormatManager` - Handles various audio file formats
   - `AudioBuffer` - Efficient audio sample buffer management

2. **DSP Module (juce_dsp)**
   - SIMD-optimized DSP algorithms
   - IIR/FIR filters
   - Convolution
   - FFT processing
   - Reverb, delay, chorus effects

3. **GUI Module**
   - Component-based UI system
   - Look-and-feel customization
   - Graphics rendering
   - OpenGL support

4. **MIDI Module**
   - MIDI input/output
   - MIDI message handling
   - Virtual MIDI devices

---

## ‚ö° Performance & Low-Latency Best Practices

### Target Latency for Live Performance
- **< 10ms total latency** (ideal for real-time musical applications)
- **64 samples @ 48kHz = 1.3ms** (achievable buffer size)
- **128 samples @ 48kHz = 2.7ms** (common for pro audio)
- **256 samples @ 48kHz = 5.3ms** (balanced performance/latency)

### JUCE 7 (2025) Performance Improvements

1. **SIMD Optimization**
   - Automatic vectorization of DSP operations
   - SSE/AVX/NEON support
   - Use `juce::dsp::SIMDRegister` for custom DSP

2. **Memory Management**
   - Reduced audio thread interruptions
   - Lock-free allocators for real-time safety
   - Pre-allocated buffer pools

3. **Lock-Free Processing**
   - `juce::AbstractFifo` - Lock-free FIFO queue
   - `juce::SpinLock` - Low-latency synchronization
   - Avoid standard library locks in audio thread

4. **Thread Pool Management**
   - Distributed DSP processing across cores
   - `juce::ThreadPool` for parallel tasks
   - Background thread for non-real-time work

### Real-Time Safety Rules

**NEVER in Audio Thread:**
- ‚ùå Memory allocation (`new`, `malloc`, `std::vector::push_back`)
- ‚ùå File I/O or network operations
- ‚ùå Locks, mutexes (use lock-free structures)
- ‚ùå System calls
- ‚ùå Console output (`std::cout`, `printf`)

**ALWAYS in Audio Thread:**
- ‚úÖ Use pre-allocated buffers
- ‚úÖ Lock-free data structures
- ‚úÖ Atomic operations for simple state
- ‚úÖ Wait-free algorithms
- ‚úÖ Fixed-size processing loops

---

## üõ†Ô∏è Project Setup Best Practices

### Projucer vs CMake

**Projucer** (JUCE's IDE)
- ‚úÖ Easy setup for beginners
- ‚úÖ Cross-platform project generation
- ‚úÖ Built-in module management
- ‚ö†Ô∏è Less flexible for complex builds

**CMake** (Recommended for 2025)
- ‚úÖ Industry-standard build system
- ‚úÖ Better integration with CI/CD
- ‚úÖ More control over dependencies
- ‚úÖ Modern C++ workflow
- üìö Use JUCE's CMake API: `juce::juce_add_plugin`

### Recommended Project Structure

```
PerformiaAudioEngine/
‚îú‚îÄ‚îÄ CMakeLists.txt
‚îú‚îÄ‚îÄ Source/
‚îÇ   ‚îú‚îÄ‚îÄ PluginProcessor.h/cpp      # Main audio processing
‚îÇ   ‚îú‚îÄ‚îÄ PluginEditor.h/cpp         # GUI (if needed)
‚îÇ   ‚îú‚îÄ‚îÄ DSP/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BeatTracker.h/cpp
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ChordDetector.h/cpp
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PitchAnalyzer.h/cpp
‚îÇ   ‚îî‚îÄ‚îÄ Utils/
‚îÇ       ‚îú‚îÄ‚îÄ RingBuffer.h           # Lock-free audio buffering
‚îÇ       ‚îî‚îÄ‚îÄ AudioMath.h            # DSP utilities
‚îú‚îÄ‚îÄ JuceLibraryCode/               # Generated by Projucer/CMake
‚îî‚îÄ‚îÄ Tests/
    ‚îî‚îÄ‚îÄ DSPTests.cpp               # Unit tests
```

---

## üîß Essential JUCE Classes for Performia

### Audio Processing

```cpp
class PerformiaAudioProcessor : public juce::AudioProcessor
{
public:
    void prepareToPlay(double sampleRate, int samplesPerBlock) override
    {
        // Initialize DSP components
        // Allocate buffers
        // Set up filters, analyzers
    }

    void processBlock(juce::AudioBuffer<float>& buffer,
                      juce::MidiBuffer& midiMessages) override
    {
        // REAL-TIME SAFE PROCESSING ONLY
        // No allocations, no locks, no I/O

        // Example: Beat detection, chord analysis
        beatTracker.process(buffer);
        chordDetector.analyzeFrame(buffer);
    }

    void releaseResources() override
    {
        // Clean up when playback stops
    }
};
```

### Lock-Free Communication (Audio Thread ‚Üî UI Thread)

```cpp
// In PluginProcessor.h
juce::AbstractFifo audioToUIFifo { 1024 };
std::vector<ChordEvent> chordEventBuffer;

// Audio thread writes
void processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer&)
{
    auto chord = detectChord(buffer);

    int start1, size1, start2, size2;
    audioToUIFifo.prepareToWrite(1, start1, size1, start2, size2);

    if (size1 > 0)
        chordEventBuffer[start1] = chord;

    audioToUIFifo.finishedWrite(size1);
}

// UI thread reads (in Timer callback)
void timerCallback() override
{
    int start1, size1, start2, size2;
    audioToUIFifo.prepareToRead(audioToUIFifo.getNumReady(),
                                 start1, size1, start2, size2);

    for (int i = 0; i < size1; ++i)
        displayChord(chordEventBuffer[start1 + i]);

    audioToUIFifo.finishedRead(size1);
}
```

### Parameter Management (Modern Approach)

```cpp
// Use AudioProcessorValueTreeState (APVTS) - JUCE best practice 2025
juce::AudioProcessorValueTreeState parameters;

// In constructor
parameters(*this, nullptr, "Parameters",
{
    std::make_unique<juce::AudioParameterFloat>(
        "gain",           // parameter ID
        "Gain",           // parameter name
        0.0f, 1.0f,      // min, max
        0.8f             // default
    ),
    std::make_unique<juce::AudioParameterChoice>(
        "mode",
        "Mode",
        juce::StringArray { "Demo", "Audio", "Live" },
        1  // default index
    )
})
```

---

## üìö Learning Resources (2025)

### Official JUCE Tutorials
- https://juce.com/learn/tutorials/
- Setup, audio plugins, DSP, GUI design
- Modern APVTS parameter system

### Comprehensive Courses
1. **Stanford Music 320c** - JUCE Development Framework
   - https://ccrma.stanford.edu/courses/320c/lectures/1/JUCE.html

2. **CppCon 2025** - Contemporary C++ for Low-Latency Systems
   - C++20/C++23 features for audio
   - Lock-free programming techniques

3. **"A Gentle Introduction to JUCE"** by Bruno Ruviaro
   - Free ebook covering fundamentals to advanced

### Example Projects
- **JUCE GitHub Examples:** https://github.com/juce-framework/JUCE/tree/master/examples
- **JUCE Plugin Template:** Start with CMake-based plugin template

---

## üéØ JUCE Implementation Plan for Performia

### Phase 1: Foundation (Issue #2)
1. Set up JUCE project with CMake
2. Implement basic audio I/O
3. Create beat detection module (< 10ms latency)
4. Real-time pitch tracking

### Phase 2: Analysis Pipeline Integration
1. Port Python audio analysis to C++ JUCE DSP
2. Real-time chord recognition
3. Tempo/beat synchronization
4. MIDI output for chord events

### Phase 3: Live Performance Engine
1. AI accompaniment generation
2. Dynamic tempo following (like Yamaha's AI Ensemble)
3. WebSocket communication with frontend
4. Sub-10ms total latency verification

### Phase 4: Advanced Features
1. Multi-track stem playback
2. Real-time key/tempo adjustment
3. SuperCollider integration for synthesis
4. Live looping and effects

---

## ‚ö†Ô∏è Common Pitfalls & Solutions

### Problem: Audio Glitches/Dropouts
**Cause:** Memory allocation or locks in audio thread
**Solution:**
- Use `juce::HeapBlock` with pre-allocation
- Profile with `juce::ScopedNoDenormals`
- Check with `-fsanitize=thread`

### Problem: High CPU Usage
**Cause:** Inefficient DSP algorithms
**Solution:**
- Use JUCE's optimized DSP classes (`juce::dsp::FFT`)
- Enable SIMD (`JUCE_USE_SIMD`)
- Profile with Instruments (macOS) or perf (Linux)

### Problem: Cross-Platform Build Issues
**Cause:** Platform-specific audio APIs
**Solution:**
- JUCE abstracts ASIO (Windows), CoreAudio (macOS), ALSA (Linux)
- Test on all target platforms early
- Use JUCE's `AudioDeviceManager` for portability

---

## üîó Integration with Performia Architecture

### JUCE ‚Üî Python Backend
```
Python Audio Analysis (offline)
    ‚Üì
Song Map JSON (lyrics, chords, timing)
    ‚Üì
JUCE Audio Engine (real-time playback)
    ‚Üì
WebSocket ‚Üí Frontend (Living Chart)
```

### JUCE ‚Üî Frontend Communication
```cpp
// JUCE sends real-time position updates
void processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer&)
{
    currentTimeMs = getCurrentPlaybackTime();

    // Send via WebSocket (in background thread!)
    backgroundThread.sendToFrontend({
        "currentTime": currentTimeMs,
        "currentChord": activeChord,
        "beat": beatPosition
    });
}
```

---

## üìä Performance Benchmarks

### Target Metrics for Performia
- **Audio Processing Latency:** < 5ms (JUCE processing only)
- **Total System Latency:** < 10ms (including I/O)
- **CPU Usage:** < 20% single core @ 128 sample buffer
- **Sample Rate:** 48kHz (industry standard for pro audio)
- **Bit Depth:** 32-bit float (JUCE native format)

### Testing Latency
```cpp
void processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer&)
{
    auto startTime = juce::Time::getHighResolutionTicks();

    // Your DSP code here
    performDSP(buffer);

    auto endTime = juce::Time::getHighResolutionTicks();
    auto elapsedMs = juce::Time::highResolutionTicksToSeconds(endTime - startTime) * 1000.0;

    // Log to console (background thread only!)
    if (elapsedMs > 1.0) // Warn if > 1ms
        logWarning("DSP took " + juce::String(elapsedMs) + "ms");
}
```

---

## üöÄ Next Steps

1. **Install JUCE:** Download from https://juce.com/get-juce/
2. **Set up CMake project:** Use JUCE's CMake API
3. **Start with simple audio I/O:** Record/playback test
4. **Build beat detector prototype:** Adapt librosa beat tracking to C++
5. **Profile performance:** Ensure < 10ms latency
6. **Integrate with Performia backend:** WebSocket communication

---

**References:**
- JUCE Official Docs: https://docs.juce.com/
- JUCE Forum: https://forum.juce.com/
- Real-Time C++ Audio Processing Guide (2025): https://markaicode.com/cpp-audio-processing-juce-7-benchmarks-2025/
- Contemporary C++ for Low-Latency Systems: CppCon 2025
